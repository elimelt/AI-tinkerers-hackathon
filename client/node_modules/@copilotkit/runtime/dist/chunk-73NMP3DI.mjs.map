{"version":3,"sources":["../src/service-adapters/langchain/utils.ts"],"sourcesContent":["import {\n  ActionExecutionMessage,\n  Message,\n  ResultMessage,\n  TextMessage,\n} from \"../../graphql/types/converted\";\nimport {\n  AIMessage,\n  AIMessageChunk,\n  BaseMessage,\n  BaseMessageChunk,\n  HumanMessage,\n  SystemMessage,\n  ToolMessage,\n} from \"@langchain/core/messages\";\nimport { DynamicStructuredTool } from \"@langchain/core/tools\";\nimport { z } from \"zod\";\nimport { ActionInput } from \"../../graphql/inputs/action.input\";\nimport { LangChainReturnType } from \"./types\";\nimport { RuntimeEventSubject } from \"../events\";\nimport { randomId } from \"@copilotkit/shared\";\n\nexport function convertMessageToLangChainMessage(message: Message): BaseMessage {\n  if (message instanceof TextMessage) {\n    if (message.role == \"user\") {\n      return new HumanMessage(message.content);\n    } else if (message.role == \"assistant\") {\n      return new AIMessage(message.content);\n    } else if (message.role === \"system\") {\n      return new SystemMessage(message.content);\n    }\n  } else if (message instanceof ActionExecutionMessage) {\n    return new AIMessage({\n      content: \"\",\n      tool_calls: [\n        {\n          id: message.id,\n          args: message.arguments,\n          name: message.name,\n        },\n      ],\n    });\n  } else if (message instanceof ResultMessage) {\n    return new ToolMessage({\n      content: message.result,\n      tool_call_id: message.actionExecutionId,\n    });\n  }\n}\n\nexport function convertJsonSchemaToZodSchema(jsonSchema: any, required: boolean): z.ZodSchema {\n  if (jsonSchema.type === \"object\") {\n    const spec: { [key: string]: z.ZodSchema } = {};\n    for (const [key, value] of Object.entries(jsonSchema.properties)) {\n      spec[key] = convertJsonSchemaToZodSchema(\n        value,\n        jsonSchema.required ? jsonSchema.required.includes(key) : false,\n      );\n    }\n    let schema = z.object(spec);\n    return !required ? schema.optional() : schema;\n  } else if (jsonSchema.type === \"string\") {\n    let schema = z.string().describe(jsonSchema.description);\n    return !required ? schema.optional() : schema;\n  } else if (jsonSchema.type === \"number\") {\n    let schema = z.number().describe(jsonSchema.description);\n    return !required ? schema.optional() : schema;\n  } else if (jsonSchema.type === \"boolean\") {\n    let schema = z.boolean().describe(jsonSchema.description);\n    return !required ? schema.optional() : schema;\n  } else if (jsonSchema.type === \"array\") {\n    let itemSchema = convertJsonSchemaToZodSchema(jsonSchema.items, false);\n    let schema = z.array(itemSchema);\n    return !required ? schema.optional() : schema;\n  }\n}\n\nexport function convertActionInputToLangChainTool(actionInput: ActionInput): any {\n  return new DynamicStructuredTool({\n    name: actionInput.name,\n    description: actionInput.description,\n    schema: convertJsonSchemaToZodSchema(\n      JSON.parse(actionInput.jsonSchema),\n      true,\n    ) as z.ZodObject<any>,\n    func: async () => {\n      return \"\";\n    },\n  });\n}\n\ninterface StreamLangChainResponseParams {\n  result: LangChainReturnType;\n  eventStream$: RuntimeEventSubject;\n  actionExecution?: {\n    id: string;\n    name: string;\n  };\n}\n\nfunction getConstructorName(object: any): string {\n  if (object && typeof object === \"object\" && object.constructor && object.constructor.name) {\n    return object.constructor.name;\n  }\n  return \"\";\n}\n\nfunction isAIMessage(message: any): message is AIMessage {\n  return getConstructorName(message) === \"AIMessage\";\n}\n\nfunction isAIMessageChunk(message: any): message is AIMessageChunk {\n  return getConstructorName(message) === \"AIMessageChunk\";\n}\n\nfunction isBaseMessageChunk(message: any): message is BaseMessageChunk {\n  return getConstructorName(message) === \"BaseMessageChunk\";\n}\n\nfunction maybeSendActionExecutionResultIsMessage(\n  eventStream$: RuntimeEventSubject,\n  actionExecution?: { id: string; name: string },\n) {\n  // language models need a result after the function call\n  // we simply let them know that we are sending a message\n  if (actionExecution) {\n    eventStream$.sendActionExecutionResult(\n      actionExecution.id,\n      actionExecution.name,\n      \"Sending a message\",\n    );\n  }\n}\n\nexport async function streamLangChainResponse({\n  result,\n  eventStream$,\n  actionExecution,\n}: StreamLangChainResponseParams) {\n  // We support several types of return values from LangChain functions:\n\n  // 1. string\n\n  if (typeof result === \"string\") {\n    if (!actionExecution) {\n      // Just send one chunk with the string as the content.\n      eventStream$.sendTextMessage(randomId(), result);\n    } else {\n      // Send as a result\n      eventStream$.sendActionExecutionResult(actionExecution.id, actionExecution.name, result);\n    }\n  }\n\n  // 2. AIMessage\n  // Send the content and function call of the AIMessage as the content of the chunk.\n  else if (isAIMessage(result)) {\n    maybeSendActionExecutionResultIsMessage(eventStream$, actionExecution);\n\n    if (result.content) {\n      eventStream$.sendTextMessage(randomId(), result.content as string);\n    }\n    for (const toolCall of result.tool_calls) {\n      eventStream$.sendActionExecution(\n        toolCall.id || randomId(),\n        toolCall.name,\n        JSON.stringify(toolCall.args),\n      );\n    }\n  }\n\n  // 3. BaseMessageChunk\n  // Send the content and function call of the AIMessage as the content of the chunk.\n  else if (isBaseMessageChunk(result)) {\n    maybeSendActionExecutionResultIsMessage(eventStream$, actionExecution);\n\n    if (result.lc_kwargs?.content) {\n      eventStream$.sendTextMessage(randomId(), result.content as string);\n    }\n    if (result.lc_kwargs?.tool_calls) {\n      for (const toolCall of result.lc_kwargs?.tool_calls) {\n        eventStream$.sendActionExecution(\n          toolCall.id || randomId(),\n          toolCall.name,\n          JSON.stringify(toolCall.args),\n        );\n      }\n    }\n  }\n\n  // 4. IterableReadableStream\n  // Stream the result of the LangChain function.\n  else if (result && \"getReader\" in result) {\n    maybeSendActionExecutionResultIsMessage(eventStream$, actionExecution);\n\n    let reader = result.getReader();\n\n    let mode: \"function\" | \"message\" | null = null;\n\n    while (true) {\n      try {\n        const { done, value } = await reader.read();\n\n        let toolCallName: string | undefined = undefined;\n        let toolCallId: string | undefined = undefined;\n        let toolCallArgs: string | undefined = undefined;\n        let hasToolCall: boolean = false;\n        let content = value?.content as string;\n\n        if (isAIMessageChunk(value)) {\n          let chunk = value.tool_call_chunks?.[0];\n          toolCallName = chunk?.name;\n          toolCallId = chunk?.id;\n          toolCallArgs = chunk?.args;\n          hasToolCall = chunk != undefined;\n        } else if (isBaseMessageChunk(value)) {\n          let chunk = value.additional_kwargs?.tool_calls?.[0];\n          toolCallName = chunk?.function?.name;\n          toolCallId = chunk?.id;\n          toolCallArgs = chunk?.function?.arguments;\n          hasToolCall = chunk?.function != undefined;\n        }\n\n        // When switching from message to function or vice versa,\n        // send the respective end event.\n        // If toolCallName is defined, it means a new tool call starts.\n        if (mode === \"message\" && (toolCallId || done)) {\n          mode = null;\n          eventStream$.sendTextMessageEnd();\n        } else if (mode === \"function\" && (!hasToolCall || done)) {\n          mode = null;\n          eventStream$.sendActionExecutionEnd();\n        }\n\n        if (done) {\n          break;\n        }\n\n        // If we send a new message type, send the appropriate start event.\n        if (mode === null) {\n          if (hasToolCall) {\n            mode = \"function\";\n            eventStream$.sendActionExecutionStart(toolCallId, toolCallName);\n          } else if (content) {\n            mode = \"message\";\n            eventStream$.sendTextMessageStart(randomId());\n          }\n        }\n\n        // send the content events\n        if (mode === \"message\" && content) {\n          eventStream$.sendTextMessageContent(content);\n        } else if (mode === \"function\" && toolCallArgs) {\n          eventStream$.sendActionExecutionArgs(toolCallArgs);\n        }\n      } catch (error) {\n        console.error(\"Error reading from stream\", error);\n        break;\n      }\n    }\n  } else if (actionExecution) {\n    eventStream$.sendActionExecutionResult(\n      actionExecution.id,\n      actionExecution.name,\n      encodeResult(result),\n    );\n  }\n\n  // unsupported type\n  else {\n    throw new Error(\"Invalid return type from LangChain function.\");\n  }\n\n  eventStream$.complete();\n}\n\nfunction encodeResult(result: any): string {\n  if (result === undefined) {\n    return \"\";\n  } else if (typeof result === \"string\") {\n    return result;\n  } else {\n    return JSON.stringify(result);\n  }\n}\n"],"mappings":"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","names":["AIMessage","HumanMessage","SystemMessage","ToolMessage","DynamicStructuredTool","z","randomId","convertMessageToLangChainMessage","message","TextMessage","role","HumanMessage","content","AIMessage","SystemMessage","ActionExecutionMessage","tool_calls","id","args","arguments","name","ResultMessage","ToolMessage","result","tool_call_id","actionExecutionId","convertJsonSchemaToZodSchema","jsonSchema","required","type","spec","key","value","Object","entries","properties","includes","schema","z","object","optional","string","describe","description","number","boolean","itemSchema","items","array","convertActionInputToLangChainTool","actionInput","DynamicStructuredTool","JSON","parse","func","getConstructorName","constructor","isAIMessage","isAIMessageChunk","isBaseMessageChunk","maybeSendActionExecutionResultIsMessage","eventStream$","actionExecution","sendActionExecutionResult","streamLangChainResponse","sendTextMessage","randomId","toolCall","sendActionExecution","stringify","lc_kwargs","reader","getReader","mode","done","read","toolCallName","undefined","toolCallId","toolCallArgs","hasToolCall","chunk","tool_call_chunks","additional_kwargs","function","sendTextMessageEnd","sendActionExecutionEnd","sendActionExecutionStart","sendTextMessageStart","sendTextMessageContent","sendActionExecutionArgs","error","console","encodeResult","Error","complete"]}